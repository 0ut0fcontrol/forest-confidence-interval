

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>scipy.optimize._minimize &mdash; forestci 0.1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="forestci 0.1.0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> forestci
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation_guide.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">forestci</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>scipy.optimize._minimize</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for scipy.optimize._minimize</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Unified interfaces to minimization algorithms.</span>

<span class="sd">Functions</span>
<span class="sd">---------</span>
<span class="sd">- minimize : minimization of a function of several variables.</span>
<span class="sd">- minimize_scalar : minimization of a function of one variable.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;minimize&#39;</span><span class="p">,</span> <span class="s1">&#39;minimize_scalar&#39;</span><span class="p">]</span>


<span class="kn">from</span> <span class="nn">warnings</span> <span class="k">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">scipy._lib.six</span> <span class="k">import</span> <span class="n">callable</span>

<span class="c1"># unconstrained minimization</span>
<span class="kn">from</span> <span class="nn">.optimize</span> <span class="k">import</span> <span class="p">(</span><span class="n">_minimize_neldermead</span><span class="p">,</span> <span class="n">_minimize_powell</span><span class="p">,</span> <span class="n">_minimize_cg</span><span class="p">,</span>
                      <span class="n">_minimize_bfgs</span><span class="p">,</span> <span class="n">_minimize_newtoncg</span><span class="p">,</span>
                      <span class="n">_minimize_scalar_brent</span><span class="p">,</span> <span class="n">_minimize_scalar_bounded</span><span class="p">,</span>
                      <span class="n">_minimize_scalar_golden</span><span class="p">,</span> <span class="n">MemoizeJac</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">._trustregion_dogleg</span> <span class="k">import</span> <span class="n">_minimize_dogleg</span>
<span class="kn">from</span> <span class="nn">._trustregion_ncg</span> <span class="k">import</span> <span class="n">_minimize_trust_ncg</span>
<span class="kn">from</span> <span class="nn">._trustregion_krylov</span> <span class="k">import</span> <span class="n">_minimize_trust_krylov</span>
<span class="kn">from</span> <span class="nn">._trustregion_exact</span> <span class="k">import</span> <span class="n">_minimize_trustregion_exact</span>

<span class="c1"># constrained minimization</span>
<span class="kn">from</span> <span class="nn">.lbfgsb</span> <span class="k">import</span> <span class="n">_minimize_lbfgsb</span>
<span class="kn">from</span> <span class="nn">.tnc</span> <span class="k">import</span> <span class="n">_minimize_tnc</span>
<span class="kn">from</span> <span class="nn">.cobyla</span> <span class="k">import</span> <span class="n">_minimize_cobyla</span>
<span class="kn">from</span> <span class="nn">.slsqp</span> <span class="k">import</span> <span class="n">_minimize_slsqp</span>


<div class="viewcode-block" id="minimize"><a class="viewcode-back" href="../../../reference/forestci.calibration.html#forestci.calibration.minimize">[docs]</a><span class="k">def</span> <span class="nf">minimize</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">hessp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="p">(),</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Minimization of scalar function of one or more variables.</span>

<span class="sd">    In general, the optimization problems are of the form::</span>

<span class="sd">        minimize f(x) subject to</span>

<span class="sd">        g_i(x) &gt;= 0,  i = 1,...,m</span>
<span class="sd">        h_j(x)  = 0,  j = 1,...,p</span>

<span class="sd">    where x is a vector of one or more variables.</span>
<span class="sd">    ``g_i(x)`` are the inequality constraints.</span>
<span class="sd">    ``h_j(x)`` are the equality constrains.</span>

<span class="sd">    Optionally, the lower and upper bounds for each element in x can also be</span>
<span class="sd">    specified using the `bounds` argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fun : callable</span>
<span class="sd">        The objective function to be minimized. Must be in the form</span>
<span class="sd">        ``f(x, *args)``. The optimizing argument, ``x``, is a 1-D array</span>
<span class="sd">        of points, and ``args`` is a tuple of any additional fixed parameters</span>
<span class="sd">        needed to completely specify the function.</span>
<span class="sd">    x0 : ndarray</span>
<span class="sd">        Initial guess. ``len(x0)`` is the dimensionality of the minimization</span>
<span class="sd">        problem.</span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Extra arguments passed to the objective function and its</span>
<span class="sd">        derivatives (Jacobian, Hessian).</span>
<span class="sd">    method : str or callable, optional</span>
<span class="sd">        Type of solver.  Should be one of</span>

<span class="sd">            - &#39;Nelder-Mead&#39; :ref:`(see here) &lt;optimize.minimize-neldermead&gt;`</span>
<span class="sd">            - &#39;Powell&#39;      :ref:`(see here) &lt;optimize.minimize-powell&gt;`</span>
<span class="sd">            - &#39;CG&#39;          :ref:`(see here) &lt;optimize.minimize-cg&gt;`</span>
<span class="sd">            - &#39;BFGS&#39;        :ref:`(see here) &lt;optimize.minimize-bfgs&gt;`</span>
<span class="sd">            - &#39;Newton-CG&#39;   :ref:`(see here) &lt;optimize.minimize-newtoncg&gt;`</span>
<span class="sd">            - &#39;L-BFGS-B&#39;    :ref:`(see here) &lt;optimize.minimize-lbfgsb&gt;`</span>
<span class="sd">            - &#39;TNC&#39;         :ref:`(see here) &lt;optimize.minimize-tnc&gt;`</span>
<span class="sd">            - &#39;COBYLA&#39;      :ref:`(see here) &lt;optimize.minimize-cobyla&gt;`</span>
<span class="sd">            - &#39;SLSQP&#39;       :ref:`(see here) &lt;optimize.minimize-slsqp&gt;`</span>
<span class="sd">            - &#39;dogleg&#39;      :ref:`(see here) &lt;optimize.minimize-dogleg&gt;`</span>
<span class="sd">            - &#39;trust-ncg&#39;   :ref:`(see here) &lt;optimize.minimize-trustncg&gt;`</span>
<span class="sd">            - &#39;trust-exact&#39; :ref:`(see here) &lt;optimize.minimize-trustexact&gt;`</span>
<span class="sd">            - &#39;trust-krylov&#39; :ref:`(see here) &lt;optimize.minimize-trustkrylov&gt;`</span>
<span class="sd">            - custom - a callable object (added in version 0.14.0),</span>
<span class="sd">              see below for description.</span>

<span class="sd">        If not given, chosen to be one of ``BFGS``, ``L-BFGS-B``, ``SLSQP``,</span>
<span class="sd">        depending if the problem has constraints or bounds.</span>
<span class="sd">    jac : bool or callable, optional</span>
<span class="sd">        Jacobian (gradient) of objective function. Only for CG, BFGS,</span>
<span class="sd">        Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg, trust-krylov,</span>
<span class="sd">        trust-region-exact.</span>
<span class="sd">        If `jac` is a Boolean and is True, `fun` is assumed to return the</span>
<span class="sd">        gradient along with the objective function. If False, the</span>
<span class="sd">        gradient will be estimated numerically.</span>
<span class="sd">        `jac` can also be a callable returning the gradient of the</span>
<span class="sd">        objective. In this case, it must accept the same arguments as `fun`.</span>
<span class="sd">    hess, hessp : callable, optional</span>
<span class="sd">        Hessian (matrix of second-order derivatives) of objective function or</span>
<span class="sd">        Hessian of objective function times an arbitrary vector p.  Only for</span>
<span class="sd">        Newton-CG, dogleg, trust-ncg, trust-krylov, trust-region-exact.</span>
<span class="sd">        Only one of `hessp` or `hess` needs to be given.  If `hess` is</span>
<span class="sd">        provided, then `hessp` will be ignored.  If neither `hess` nor</span>
<span class="sd">        `hessp` is provided, then the Hessian product will be approximated</span>
<span class="sd">        using finite differences on `jac`. `hessp` must compute the Hessian</span>
<span class="sd">        times an arbitrary vector.</span>
<span class="sd">    bounds : sequence, optional</span>
<span class="sd">        Bounds for variables (only for L-BFGS-B, TNC and SLSQP).</span>
<span class="sd">        ``(min, max)`` pairs for each element in ``x``, defining</span>
<span class="sd">        the bounds on that parameter. Use None for one of ``min`` or</span>
<span class="sd">        ``max`` when there is no bound in that direction.</span>
<span class="sd">    constraints : dict or sequence of dict, optional</span>
<span class="sd">        Constraints definition (only for COBYLA and SLSQP).</span>
<span class="sd">        Each constraint is defined in a dictionary with fields:</span>

<span class="sd">            type : str</span>
<span class="sd">                Constraint type: &#39;eq&#39; for equality, &#39;ineq&#39; for inequality.</span>
<span class="sd">            fun : callable</span>
<span class="sd">                The function defining the constraint.</span>
<span class="sd">            jac : callable, optional</span>
<span class="sd">                The Jacobian of `fun` (only for SLSQP).</span>
<span class="sd">            args : sequence, optional</span>
<span class="sd">                Extra arguments to be passed to the function and Jacobian.</span>

<span class="sd">        Equality constraint means that the constraint function result is to</span>
<span class="sd">        be zero whereas inequality means that it is to be non-negative.</span>
<span class="sd">        Note that COBYLA only supports inequality constraints.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance for termination. For detailed control, use solver-specific</span>
<span class="sd">        options.</span>
<span class="sd">    options : dict, optional</span>
<span class="sd">        A dictionary of solver options. All methods accept the following</span>
<span class="sd">        generic options:</span>

<span class="sd">            maxiter : int</span>
<span class="sd">                Maximum number of iterations to perform.</span>
<span class="sd">            disp : bool</span>
<span class="sd">                Set to True to print convergence messages.</span>

<span class="sd">        For method-specific options, see :func:`show_options()`.</span>
<span class="sd">    callback : callable, optional</span>
<span class="sd">        Called after each iteration, as ``callback(xk)``, where ``xk`` is the</span>
<span class="sd">        current parameter vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : OptimizeResult</span>
<span class="sd">        The optimization result represented as a ``OptimizeResult`` object.</span>
<span class="sd">        Important attributes are: ``x`` the solution array, ``success`` a</span>
<span class="sd">        Boolean flag indicating if the optimizer exited successfully and</span>
<span class="sd">        ``message`` which describes the cause of the termination. See</span>
<span class="sd">        `OptimizeResult` for a description of other attributes.</span>


<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    minimize_scalar : Interface to minimization algorithms for scalar</span>
<span class="sd">        univariate functions</span>
<span class="sd">    show_options : Additional options accepted by the solvers</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This section describes the available solvers that can be selected by the</span>
<span class="sd">    &#39;method&#39; parameter. The default method is *BFGS*.</span>

<span class="sd">    **Unconstrained minimization**</span>

<span class="sd">    Method :ref:`Nelder-Mead &lt;optimize.minimize-neldermead&gt;` uses the</span>
<span class="sd">    Simplex algorithm [1]_, [2]_. This algorithm is robust in many</span>
<span class="sd">    applications. However, if numerical computation of derivative can be</span>
<span class="sd">    trusted, other algorithms using the first and/or second derivatives</span>
<span class="sd">    information might be preferred for their better performance in</span>
<span class="sd">    general.</span>

<span class="sd">    Method :ref:`Powell &lt;optimize.minimize-powell&gt;` is a modification</span>
<span class="sd">    of Powell&#39;s method [3]_, [4]_ which is a conjugate direction</span>
<span class="sd">    method. It performs sequential one-dimensional minimizations along</span>
<span class="sd">    each vector of the directions set (`direc` field in `options` and</span>
<span class="sd">    `info`), which is updated at each iteration of the main</span>
<span class="sd">    minimization loop. The function need not be differentiable, and no</span>
<span class="sd">    derivatives are taken.</span>

<span class="sd">    Method :ref:`CG &lt;optimize.minimize-cg&gt;` uses a nonlinear conjugate</span>
<span class="sd">    gradient algorithm by Polak and Ribiere, a variant of the</span>
<span class="sd">    Fletcher-Reeves method described in [5]_ pp.  120-122. Only the</span>
<span class="sd">    first derivatives are used.</span>

<span class="sd">    Method :ref:`BFGS &lt;optimize.minimize-bfgs&gt;` uses the quasi-Newton</span>
<span class="sd">    method of Broyden, Fletcher, Goldfarb, and Shanno (BFGS) [5]_</span>
<span class="sd">    pp. 136. It uses the first derivatives only. BFGS has proven good</span>
<span class="sd">    performance even for non-smooth optimizations. This method also</span>
<span class="sd">    returns an approximation of the Hessian inverse, stored as</span>
<span class="sd">    `hess_inv` in the OptimizeResult object.</span>

<span class="sd">    Method :ref:`Newton-CG &lt;optimize.minimize-newtoncg&gt;` uses a</span>
<span class="sd">    Newton-CG algorithm [5]_ pp. 168 (also known as the truncated</span>
<span class="sd">    Newton method). It uses a CG method to the compute the search</span>
<span class="sd">    direction. See also *TNC* method for a box-constrained</span>
<span class="sd">    minimization with a similar algorithm. Suitable for large-scale</span>
<span class="sd">    problems.</span>

<span class="sd">    Method :ref:`dogleg &lt;optimize.minimize-dogleg&gt;` uses the dog-leg</span>
<span class="sd">    trust-region algorithm [5]_ for unconstrained minimization. This</span>
<span class="sd">    algorithm requires the gradient and Hessian; furthermore the</span>
<span class="sd">    Hessian is required to be positive definite.</span>

<span class="sd">    Method :ref:`trust-ncg &lt;optimize.minimize-trustncg&gt;` uses the</span>
<span class="sd">    Newton conjugate gradient trust-region algorithm [5]_ for</span>
<span class="sd">    unconstrained minimization. This algorithm requires the gradient</span>
<span class="sd">    and either the Hessian or a function that computes the product of</span>
<span class="sd">    the Hessian with a given vector. Suitable for large-scale problems.</span>

<span class="sd">    Method :ref:`trust-krylov &lt;optimize.minimize-trustkrylov&gt;` uses</span>
<span class="sd">    the Newton GLTR trust-region algorithm [14]_, [15]_ for unconstrained</span>
<span class="sd">    minimization. This algorithm requires the gradient</span>
<span class="sd">    and either the Hessian or a function that computes the product of</span>
<span class="sd">    the Hessian with a given vector. Suitable for large-scale problems.</span>
<span class="sd">    On indefinite problems it requires usually less iterations than the</span>
<span class="sd">    `trust-ncg` method and is recommended for medium and large-scale problems.</span>

<span class="sd">    Method :ref:`trust-exact &lt;optimize.minimize-trustexact&gt;`</span>
<span class="sd">    is a trust-region method for unconstrained minimization in which</span>
<span class="sd">    quadratic subproblems are solved almost exactly [13]_. This</span>
<span class="sd">    algorithm requires the gradient and the Hessian (which is</span>
<span class="sd">    *not* required to be positive definite). It is, in many</span>
<span class="sd">    situations, the Newton method to converge in fewer iteraction</span>
<span class="sd">    and the most recommended for small and medium-size problems.</span>

<span class="sd">    **Constrained minimization**</span>

<span class="sd">    Method :ref:`L-BFGS-B &lt;optimize.minimize-lbfgsb&gt;` uses the L-BFGS-B</span>
<span class="sd">    algorithm [6]_, [7]_ for bound constrained minimization.</span>

<span class="sd">    Method :ref:`TNC &lt;optimize.minimize-tnc&gt;` uses a truncated Newton</span>
<span class="sd">    algorithm [5]_, [8]_ to minimize a function with variables subject</span>
<span class="sd">    to bounds. This algorithm uses gradient information; it is also</span>
<span class="sd">    called Newton Conjugate-Gradient. It differs from the *Newton-CG*</span>
<span class="sd">    method described above as it wraps a C implementation and allows</span>
<span class="sd">    each variable to be given upper and lower bounds.</span>

<span class="sd">    Method :ref:`COBYLA &lt;optimize.minimize-cobyla&gt;` uses the</span>
<span class="sd">    Constrained Optimization BY Linear Approximation (COBYLA) method</span>
<span class="sd">    [9]_, [10]_, [11]_. The algorithm is based on linear</span>
<span class="sd">    approximations to the objective function and each constraint. The</span>
<span class="sd">    method wraps a FORTRAN implementation of the algorithm. The</span>
<span class="sd">    constraints functions &#39;fun&#39; may return either a single number</span>
<span class="sd">    or an array or list of numbers.</span>

<span class="sd">    Method :ref:`SLSQP &lt;optimize.minimize-slsqp&gt;` uses Sequential</span>
<span class="sd">    Least SQuares Programming to minimize a function of several</span>
<span class="sd">    variables with any combination of bounds, equality and inequality</span>
<span class="sd">    constraints. The method wraps the SLSQP Optimization subroutine</span>
<span class="sd">    originally implemented by Dieter Kraft [12]_. Note that the</span>
<span class="sd">    wrapper handles infinite values in bounds by converting them into</span>
<span class="sd">    large floating values.</span>

<span class="sd">    **Custom minimizers**</span>

<span class="sd">    It may be useful to pass a custom minimization method, for example</span>
<span class="sd">    when using a frontend to this method such as `scipy.optimize.basinhopping`</span>
<span class="sd">    or a different library.  You can simply pass a callable as the ``method``</span>
<span class="sd">    parameter.</span>

<span class="sd">    The callable is called as ``method(fun, x0, args, **kwargs, **options)``</span>
<span class="sd">    where ``kwargs`` corresponds to any other parameters passed to `minimize`</span>
<span class="sd">    (such as `callback`, `hess`, etc.), except the `options` dict, which has</span>
<span class="sd">    its contents also passed as `method` parameters pair by pair.  Also, if</span>
<span class="sd">    `jac` has been passed as a bool type, `jac` and `fun` are mangled so that</span>
<span class="sd">    `fun` returns just the function values and `jac` is converted to a function</span>
<span class="sd">    returning the Jacobian.  The method shall return an ``OptimizeResult``</span>
<span class="sd">    object.</span>

<span class="sd">    The provided `method` callable must be able to accept (and possibly ignore)</span>
<span class="sd">    arbitrary parameters; the set of parameters accepted by `minimize` may</span>
<span class="sd">    expand in future versions and then these parameters will be passed to</span>
<span class="sd">    the method.  You can find an example in the scipy.optimize tutorial.</span>

<span class="sd">    .. versionadded:: 0.11.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Nelder, J A, and R Mead. 1965. A Simplex Method for Function</span>
<span class="sd">        Minimization. The Computer Journal 7: 308-13.</span>
<span class="sd">    .. [2] Wright M H. 1996. Direct search methods: Once scorned, now</span>
<span class="sd">        respectable, in Numerical Analysis 1995: Proceedings of the 1995</span>
<span class="sd">        Dundee Biennial Conference in Numerical Analysis (Eds. D F</span>
<span class="sd">        Griffiths and G A Watson). Addison Wesley Longman, Harlow, UK.</span>
<span class="sd">        191-208.</span>
<span class="sd">    .. [3] Powell, M J D. 1964. An efficient method for finding the minimum of</span>
<span class="sd">       a function of several variables without calculating derivatives. The</span>
<span class="sd">       Computer Journal 7: 155-162.</span>
<span class="sd">    .. [4] Press W, S A Teukolsky, W T Vetterling and B P Flannery.</span>
<span class="sd">       Numerical Recipes (any edition), Cambridge University Press.</span>
<span class="sd">    .. [5] Nocedal, J, and S J Wright. 2006. Numerical Optimization.</span>
<span class="sd">       Springer New York.</span>
<span class="sd">    .. [6] Byrd, R H and P Lu and J. Nocedal. 1995. A Limited Memory</span>
<span class="sd">       Algorithm for Bound Constrained Optimization. SIAM Journal on</span>
<span class="sd">       Scientific and Statistical Computing 16 (5): 1190-1208.</span>
<span class="sd">    .. [7] Zhu, C and R H Byrd and J Nocedal. 1997. L-BFGS-B: Algorithm</span>
<span class="sd">       778: L-BFGS-B, FORTRAN routines for large scale bound constrained</span>
<span class="sd">       optimization. ACM Transactions on Mathematical Software 23 (4):</span>
<span class="sd">       550-560.</span>
<span class="sd">    .. [8] Nash, S G. Newton-Type Minimization Via the Lanczos Method.</span>
<span class="sd">       1984. SIAM Journal of Numerical Analysis 21: 770-778.</span>
<span class="sd">    .. [9] Powell, M J D. A direct search optimization method that models</span>
<span class="sd">       the objective and constraint functions by linear interpolation.</span>
<span class="sd">       1994. Advances in Optimization and Numerical Analysis, eds. S. Gomez</span>
<span class="sd">       and J-P Hennart, Kluwer Academic (Dordrecht), 51-67.</span>
<span class="sd">    .. [10] Powell M J D. Direct search algorithms for optimization</span>
<span class="sd">       calculations. 1998. Acta Numerica 7: 287-336.</span>
<span class="sd">    .. [11] Powell M J D. A view of algorithms for optimization without</span>
<span class="sd">       derivatives. 2007.Cambridge University Technical Report DAMTP</span>
<span class="sd">       2007/NA03</span>
<span class="sd">    .. [12] Kraft, D. A software package for sequential quadratic</span>
<span class="sd">       programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace</span>
<span class="sd">       Center -- Institute for Flight Mechanics, Koln, Germany.</span>
<span class="sd">    .. [13] Conn, A. R., Gould, N. I., and Toint, P. L.</span>
<span class="sd">       Trust region methods. 2000. Siam. pp. 169-200.</span>
<span class="sd">    .. [14] F. Lenders, C. Kirches, A. Potschka: &quot;trlib: A vector-free</span>
<span class="sd">       implementation of the GLTR method for iterative solution of</span>
<span class="sd">       the trust region problem&quot;, https://arxiv.org/abs/1611.04718</span>
<span class="sd">    .. [15] N. Gould, S. Lucidi, M. Roma, P. Toint: &quot;Solving the</span>
<span class="sd">       Trust-Region Subproblem using the Lanczos Method&quot;,</span>
<span class="sd">       SIAM J. Optim., 9(2), 504--525, (1999).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Let us consider the problem of minimizing the Rosenbrock function. This</span>
<span class="sd">    function (and its respective derivatives) is implemented in `rosen`</span>
<span class="sd">    (resp. `rosen_der`, `rosen_hess`) in the `scipy.optimize`.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.optimize import minimize, rosen, rosen_der</span>

<span class="sd">    A simple application of the *Nelder-Mead* method is:</span>

<span class="sd">    &gt;&gt;&gt; x0 = [1.3, 0.7, 0.8, 1.9, 1.2]</span>
<span class="sd">    &gt;&gt;&gt; res = minimize(rosen, x0, method=&#39;Nelder-Mead&#39;, tol=1e-6)</span>
<span class="sd">    &gt;&gt;&gt; res.x</span>
<span class="sd">    array([ 1.,  1.,  1.,  1.,  1.])</span>

<span class="sd">    Now using the *BFGS* algorithm, using the first derivative and a few</span>
<span class="sd">    options:</span>

<span class="sd">    &gt;&gt;&gt; res = minimize(rosen, x0, method=&#39;BFGS&#39;, jac=rosen_der,</span>
<span class="sd">    ...                options={&#39;gtol&#39;: 1e-6, &#39;disp&#39;: True})</span>
<span class="sd">    Optimization terminated successfully.</span>
<span class="sd">             Current function value: 0.000000</span>
<span class="sd">             Iterations: 26</span>
<span class="sd">             Function evaluations: 31</span>
<span class="sd">             Gradient evaluations: 31</span>
<span class="sd">    &gt;&gt;&gt; res.x</span>
<span class="sd">    array([ 1.,  1.,  1.,  1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; print(res.message)</span>
<span class="sd">    Optimization terminated successfully.</span>
<span class="sd">    &gt;&gt;&gt; res.hess_inv</span>
<span class="sd">    array([[ 0.00749589,  0.01255155,  0.02396251,  0.04750988,  0.09495377],  # may vary</span>
<span class="sd">           [ 0.01255155,  0.02510441,  0.04794055,  0.09502834,  0.18996269],</span>
<span class="sd">           [ 0.02396251,  0.04794055,  0.09631614,  0.19092151,  0.38165151],</span>
<span class="sd">           [ 0.04750988,  0.09502834,  0.19092151,  0.38341252,  0.7664427 ],</span>
<span class="sd">           [ 0.09495377,  0.18996269,  0.38165151,  0.7664427,   1.53713523]])</span>


<span class="sd">    Next, consider a minimization problem with several constraints (namely</span>
<span class="sd">    Example 16.4 from [5]_). The objective function is:</span>

<span class="sd">    &gt;&gt;&gt; fun = lambda x: (x[0] - 1)**2 + (x[1] - 2.5)**2</span>

<span class="sd">    There are three constraints defined as:</span>

<span class="sd">    &gt;&gt;&gt; cons = ({&#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: lambda x:  x[0] - 2 * x[1] + 2},</span>
<span class="sd">    ...         {&#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: lambda x: -x[0] - 2 * x[1] + 6},</span>
<span class="sd">    ...         {&#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: lambda x: -x[0] + 2 * x[1] + 2})</span>

<span class="sd">    And variables must be positive, hence the following bounds:</span>

<span class="sd">    &gt;&gt;&gt; bnds = ((0, None), (0, None))</span>

<span class="sd">    The optimization problem is solved using the SLSQP method as:</span>

<span class="sd">    &gt;&gt;&gt; res = minimize(fun, (2, 0), method=&#39;SLSQP&#39;, bounds=bnds,</span>
<span class="sd">    ...                constraints=cons)</span>

<span class="sd">    It should converge to the theoretical solution (1.4 ,1.7).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x0</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">typecodes</span><span class="p">[</span><span class="s2">&quot;AllInteger&quot;</span><span class="p">]:</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Select automatically</span>
        <span class="k">if</span> <span class="n">constraints</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;SLSQP&#39;</span>
        <span class="k">elif</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;L-BFGS-B&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;BFGS&#39;</span>

    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="s2">&quot;_custom&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># check if optional parameters are supported by the selected method</span>
    <span class="c1"># - jac</span>
    <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nelder-mead&#39;</span><span class="p">,</span> <span class="s1">&#39;powell&#39;</span><span class="p">,</span> <span class="s1">&#39;cobyla&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">jac</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> does not use gradient information (jac).&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span>
             <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="c1"># - hess</span>
    <span class="k">if</span> <span class="n">meth</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;newton-cg&#39;</span><span class="p">,</span> <span class="s1">&#39;dogleg&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-ncg&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-krylov&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;trust-exact&#39;</span><span class="p">,</span> <span class="s1">&#39;_custom&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hess</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> does not use Hessian information (hess).&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span>
             <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="c1"># - hessp</span>
    <span class="k">if</span> <span class="n">meth</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;newton-cg&#39;</span><span class="p">,</span> <span class="s1">&#39;dogleg&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-ncg&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;trust-krylov&#39;</span><span class="p">,</span> <span class="s1">&#39;_custom&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hessp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> does not use Hessian-vector product &#39;</span>
                <span class="s1">&#39;information (hessp).&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="c1"># - constraints or bounds</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">meth</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nelder-mead&#39;</span><span class="p">,</span> <span class="s1">&#39;powell&#39;</span><span class="p">,</span> <span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="s1">&#39;bfgs&#39;</span><span class="p">,</span> <span class="s1">&#39;newton-cg&#39;</span><span class="p">,</span> <span class="s1">&#39;dogleg&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;trust-ncg&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">constraints</span><span class="p">))):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> cannot handle constraints nor bounds.&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span>
             <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">,</span> <span class="s1">&#39;tnc&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">constraints</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> cannot handle constraints.&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span>
             <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;cobyla&#39;</span> <span class="ow">and</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> cannot handle bounds.&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span>
             <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="c1"># - callback</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">meth</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cobyla&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> does not support callback.&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="c1"># - return_all</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">meth</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">,</span> <span class="s1">&#39;tnc&#39;</span><span class="p">,</span> <span class="s1">&#39;cobyla&#39;</span><span class="p">,</span> <span class="s1">&#39;slsqp&#39;</span><span class="p">]</span> <span class="ow">and</span>
            <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return_all&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Method </span><span class="si">%s</span><span class="s1"> does not support the return_all option.&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">,</span>
             <span class="ne">RuntimeWarning</span><span class="p">)</span>

    <span class="c1"># fun also returns the jacobian</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">jac</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">jac</span><span class="p">):</span>
            <span class="n">fun</span> <span class="o">=</span> <span class="n">MemoizeJac</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="n">derivative</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># set default tolerances</span>
    <span class="k">if</span> <span class="n">tol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;nelder-mead&#39;</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;xatol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;fatol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;newton-cg&#39;</span><span class="p">,</span> <span class="s1">&#39;powell&#39;</span><span class="p">,</span> <span class="s1">&#39;tnc&#39;</span><span class="p">]:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;xtol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;powell&#39;</span><span class="p">,</span> <span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">,</span> <span class="s1">&#39;tnc&#39;</span><span class="p">,</span> <span class="s1">&#39;slsqp&#39;</span><span class="p">]:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ftol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;bfgs&#39;</span><span class="p">,</span> <span class="s1">&#39;cg&#39;</span><span class="p">,</span> <span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">,</span> <span class="s1">&#39;tnc&#39;</span><span class="p">,</span> <span class="s1">&#39;dogleg&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;trust-ncg&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-exact&#39;</span><span class="p">,</span> <span class="s1">&#39;trust-krylov&#39;</span><span class="p">]:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;gtol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cobyla&#39;</span><span class="p">,</span> <span class="s1">&#39;_custom&#39;</span><span class="p">]:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;tol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;_custom&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">,</span> <span class="n">hess</span><span class="o">=</span><span class="n">hess</span><span class="p">,</span> <span class="n">hessp</span><span class="o">=</span><span class="n">hessp</span><span class="p">,</span>
                      <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span><span class="p">,</span>
                      <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;nelder-mead&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_neldermead</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;powell&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_powell</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;cg&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_cg</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;bfgs&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_bfgs</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;newton-cg&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_newtoncg</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">hess</span><span class="p">,</span> <span class="n">hessp</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_lbfgsb</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span>
                                <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;tnc&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_tnc</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;cobyla&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_cobyla</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;slsqp&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_slsqp</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span>
                               <span class="n">constraints</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;dogleg&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_dogleg</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">hess</span><span class="p">,</span>
                                <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;trust-ncg&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_trust_ncg</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">hess</span><span class="p">,</span> <span class="n">hessp</span><span class="p">,</span>
                                   <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;trust-krylov&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_trust_krylov</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">hess</span><span class="p">,</span> <span class="n">hessp</span><span class="p">,</span>
                                      <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;trust-exact&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_trustregion_exact</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">hess</span><span class="p">,</span>
                                           <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown solver </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">minimize_scalar</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">bracket</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span>
                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;brent&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Minimization of scalar function of one variable.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fun : callable</span>
<span class="sd">        Objective function.</span>
<span class="sd">        Scalar function, must return a scalar.</span>
<span class="sd">    bracket : sequence, optional</span>
<span class="sd">        For methods &#39;brent&#39; and &#39;golden&#39;, `bracket` defines the bracketing</span>
<span class="sd">        interval and can either have three items ``(a, b, c)`` so that</span>
<span class="sd">        ``a &lt; b &lt; c`` and ``fun(b) &lt; fun(a), fun(c)`` or two items ``a`` and</span>
<span class="sd">        ``c`` which are assumed to be a starting interval for a downhill</span>
<span class="sd">        bracket search (see `bracket`); it doesn&#39;t always mean that the</span>
<span class="sd">        obtained solution will satisfy ``a &lt;= x &lt;= c``.</span>
<span class="sd">    bounds : sequence, optional</span>
<span class="sd">        For method &#39;bounded&#39;, `bounds` is mandatory and must have two items</span>
<span class="sd">        corresponding to the optimization bounds.</span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Extra arguments passed to the objective function.</span>
<span class="sd">    method : str or callable, optional</span>
<span class="sd">        Type of solver.  Should be one of:</span>

<span class="sd">            - &#39;Brent&#39;     :ref:`(see here) &lt;optimize.minimize_scalar-brent&gt;`</span>
<span class="sd">            - &#39;Bounded&#39;   :ref:`(see here) &lt;optimize.minimize_scalar-bounded&gt;`</span>
<span class="sd">            - &#39;Golden&#39;    :ref:`(see here) &lt;optimize.minimize_scalar-golden&gt;`</span>
<span class="sd">            - custom - a callable object (added in version 0.14.0), see below</span>

<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance for termination. For detailed control, use solver-specific</span>
<span class="sd">        options.</span>
<span class="sd">    options : dict, optional</span>
<span class="sd">        A dictionary of solver options.</span>

<span class="sd">            maxiter : int</span>
<span class="sd">                Maximum number of iterations to perform.</span>
<span class="sd">            disp : bool</span>
<span class="sd">                Set to True to print convergence messages.</span>

<span class="sd">        See :func:`show_options()` for solver-specific options.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : OptimizeResult</span>
<span class="sd">        The optimization result represented as a ``OptimizeResult`` object.</span>
<span class="sd">        Important attributes are: ``x`` the solution array, ``success`` a</span>
<span class="sd">        Boolean flag indicating if the optimizer exited successfully and</span>
<span class="sd">        ``message`` which describes the cause of the termination. See</span>
<span class="sd">        `OptimizeResult` for a description of other attributes.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    minimize : Interface to minimization algorithms for scalar multivariate</span>
<span class="sd">        functions</span>
<span class="sd">    show_options : Additional options accepted by the solvers</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This section describes the available solvers that can be selected by the</span>
<span class="sd">    &#39;method&#39; parameter. The default method is *Brent*.</span>

<span class="sd">    Method :ref:`Brent &lt;optimize.minimize_scalar-brent&gt;` uses Brent&#39;s</span>
<span class="sd">    algorithm to find a local minimum.  The algorithm uses inverse</span>
<span class="sd">    parabolic interpolation when possible to speed up convergence of</span>
<span class="sd">    the golden section method.</span>

<span class="sd">    Method :ref:`Golden &lt;optimize.minimize_scalar-golden&gt;` uses the</span>
<span class="sd">    golden section search technique. It uses analog of the bisection</span>
<span class="sd">    method to decrease the bracketed interval. It is usually</span>
<span class="sd">    preferable to use the *Brent* method.</span>

<span class="sd">    Method :ref:`Bounded &lt;optimize.minimize_scalar-bounded&gt;` can</span>
<span class="sd">    perform bounded minimization. It uses the Brent method to find a</span>
<span class="sd">    local minimum in the interval x1 &lt; xopt &lt; x2.</span>

<span class="sd">    **Custom minimizers**</span>

<span class="sd">    It may be useful to pass a custom minimization method, for example</span>
<span class="sd">    when using some library frontend to minimize_scalar.  You can simply</span>
<span class="sd">    pass a callable as the ``method`` parameter.</span>

<span class="sd">    The callable is called as ``method(fun, args, **kwargs, **options)``</span>
<span class="sd">    where ``kwargs`` corresponds to any other parameters passed to `minimize`</span>
<span class="sd">    (such as `bracket`, `tol`, etc.), except the `options` dict, which has</span>
<span class="sd">    its contents also passed as `method` parameters pair by pair.  The method</span>
<span class="sd">    shall return an ``OptimizeResult`` object.</span>

<span class="sd">    The provided `method` callable must be able to accept (and possibly ignore)</span>
<span class="sd">    arbitrary parameters; the set of parameters accepted by `minimize` may</span>
<span class="sd">    expand in future versions and then these parameters will be passed to</span>
<span class="sd">    the method.  You can find an example in the scipy.optimize tutorial.</span>

<span class="sd">    .. versionadded:: 0.11.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider the problem of minimizing the following function.</span>

<span class="sd">    &gt;&gt;&gt; def f(x):</span>
<span class="sd">    ...     return (x - 2) * x * (x + 2)**2</span>

<span class="sd">    Using the *Brent* method, we find the local minimum as:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.optimize import minimize_scalar</span>
<span class="sd">    &gt;&gt;&gt; res = minimize_scalar(f)</span>
<span class="sd">    &gt;&gt;&gt; res.x</span>
<span class="sd">    1.28077640403</span>

<span class="sd">    Using the *Bounded* method, we find a local minimum with specified</span>
<span class="sd">    bounds as:</span>

<span class="sd">    &gt;&gt;&gt; res = minimize_scalar(f, bounds=(-3, -1), method=&#39;bounded&#39;)</span>
<span class="sd">    &gt;&gt;&gt; res.x</span>
<span class="sd">    -2.0000002026</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>

    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="s2">&quot;_custom&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">tol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;bounded&#39;</span> <span class="ow">and</span> <span class="s1">&#39;xatol&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Method &#39;bounded&#39; does not support relative tolerance in x; &quot;</span>
                 <span class="s2">&quot;defaulting to absolute tolerance.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="n">options</span><span class="p">[</span><span class="s1">&#39;xatol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;_custom&#39;</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;tol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;xtol&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;_custom&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">bracket</span><span class="o">=</span><span class="n">bracket</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;brent&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_scalar_brent</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">bracket</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;bounded&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The `bounds` parameter is mandatory for &#39;</span>
                             <span class="s1">&#39;method `bounded`.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_minimize_scalar_bounded</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">meth</span> <span class="o">==</span> <span class="s1">&#39;golden&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_minimize_scalar_golden</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">bracket</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown solver </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Kivan Polimis, Ariel Rokem, Bryna Hazelton, The University of Washington eScience Institute.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>